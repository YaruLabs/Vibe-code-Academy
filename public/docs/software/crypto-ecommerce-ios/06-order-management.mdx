
# üì¶ Phase 6: Order Management & Post-Purchase Experience

Building the **complete order lifecycle system** from creation to delivery tracking. This phase implements order history, status updates, refunds, and customer support features integrated with blockchain state.

Enterprise-grade order management with real-time blockchain synchronization and offline support.

---

## ‚ö° ACTION: IMPLEMENT ORDER SYSTEM

**Mission:** Use **Claude** or your **AI Assistant**. Copy the prompt below and paste it into the chat.

<div style={{
  background: 'linear-gradient(135deg, #f59e0b, #84cc16)',
  padding: '3px',
  borderRadius: '16px',
  margin: '30px 0',
  boxShadow: '0 0 60px -15px rgba(245, 158, 11, 0.6)'
}}>
  <div style={{
    background: '#1a1508',
    borderRadius: '13px',
    color: '#e2e8f0',
    overflow: 'hidden',
    fontFamily: 'Menlo, Monaco, Consolas, monospace',
    position: 'relative'
  }}>

    {/* Header Bar */}
    <div style={{
      background: 'rgba(255, 255, 255, 0.05)',
      borderBottom: '1px solid #334155',
      padding: '12px 20px',
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center'
    }}>
      <div style={{display: 'flex', alignItems: 'center', gap: '12px'}}>
        <div style={{
            width:'12px', height:'12px', background:'#f59e0b', borderRadius:'50%',
            boxShadow:'0 0 12px #f59e0b'
        }}></div>
        <span style={{color: '#fbbf24', fontWeight: 'bold', fontSize: '0.85rem', letterSpacing: '0.5px'}}>
          ORDER_MANAGER.swift
        </span>
        <span style={{
            background: 'rgba(132, 204, 22, 0.2)', color: '#bef264', fontSize: '0.65rem',
            padding: '2px 8px', borderRadius: '4px', border: '1px solid rgba(132, 204, 22, 0.3)'
        }}>BLOCKCHAIN + OFFLINE</span>
      </div>

      <button
        style={{
            background: 'linear-gradient(90deg, #f59e0b, #84cc16)',
            border: 'none',
            color: 'white',
            padding: '8px 16px',
            borderRadius: '6px',
            fontSize: '0.75rem',
            cursor: 'pointer',
            fontWeight: 'bold',
            display: 'flex', alignItems: 'center', gap: '8px',
            transition: 'transform 0.1s',
            boxShadow: '0 4px 12px rgba(245, 158, 11, 0.4)'
        }}
        onMouseOver={(e) => e.currentTarget.style.transform = 'translateY(-1px)'}
        onMouseOut={(e) => e.currentTarget.style.transform = 'translateY(0)'}
        onClick={() => {
            const promptText = document.getElementById('order-prompt').innerText;
            navigator.clipboard.writeText(promptText);
            alert("Order Management Blueprint Copied! üì¶");
        }}
      >
        <span>‚ö° COPY ORDER MANAGEMENT PROMPT</span>
      </button>
    </div>

    {/* Scrollable Content Area */}
    <div id="order-prompt" style={{
      padding: '24px',
      maxHeight: '500px',
      overflowY: 'auto',
      whiteSpace: 'pre-wrap',
      fontSize: '0.85rem',
      lineHeight: '1.6',
      color: '#cbd5e1'
    }}>
{`You are a senior backend and iOS systems architect specializing in e-commerce order management, CoreData persistence, and blockchain state synchronization. Your task is to implement a complete, production-ready order management system for a crypto e-commerce iOS app.

====================================================================
üéØ ORDER MANAGEMENT REQUIREMENTS
====================================================================

Core Features:
1. Order creation and storage (local + blockchain)
2. Order history with filtering and search
3. Order detail view with all information
4. Status tracking (Placed ‚Üí Paid ‚Üí Shipped ‚Üí Delivered)
5. Refund requests and processing
6. Order cancellation
7. Dispute handling
8. Real-time blockchain sync
9. Offline support with sync queue
10. Push notifications for order updates

Data Sources:
- Blockchain: OrderManager smart contract (source of truth)
- Local: CoreData (for offline access and caching)
- Backend API: Optional for product metadata and shipping

====================================================================
üìê ARCHITECTURE LAYERS
====================================================================

1. OrderService
   - Interacts with OrderManager smart contract
   - Reads order events from blockchain
   - Submits status updates
   - Handles cancellations and refunds

2. OrderSyncManager
   - Syncs blockchain orders to local database
   - Handles offline queue
   - Background sync with periodic refresh
   - Conflict resolution

3. OrderRepository (implements OrderRepositoryProtocol)
   - Domain layer interface
   - Coordinates blockchain + local storage
   - Returns domain Order entities

4. CoreData Stack
   - OrderEntity (persisted model)
   - OrderItemEntity
   - TransactionEntity
   - Relationships and indexes

5. ViewModels
   - OrderHistoryViewModel
   - OrderDetailViewModel
   - RefundRequestViewModel

====================================================================
üìù IMPLEMENTATION: CoreData Models
====================================================================

OrderEntity:
- id: UUID (primary key)
- blockchainOrderId: Int64 (smart contract order ID)
- buyerAddress: String
- totalAmount: Decimal
- paymentStatus: String (enum: Pending, Paid, Failed)
- orderStatus: String (enum: Placed, Paid, Shipped, Delivered, Cancelled)
- transactionHash: String?
- paymentId: Int64?
- createdAt: Date
- updatedAt: Date
- lastSyncedAt: Date?
- needsSync: Bool (flag for offline changes)
- items: Relationship to OrderItemEntity (one-to-many)

OrderItemEntity:
- id: UUID
- productId: String
- productName: String
- productImage: String?
- quantity: Int16
- pricePerUnit: Decimal
- totalPrice: Decimal
- order: Relationship to OrderEntity (many-to-one)

TransactionEntity:
- id: UUID
- transactionHash: String
- blockNumber: Int64
- timestamp: Date
- gasUsed: String
- status: String (Pending, Confirmed, Failed)
- order: Relationship to OrderEntity (one-to-one)

====================================================================
üìù IMPLEMENTATION: OrderService
====================================================================

import Foundation
import web3
import BigInt

class OrderService {
    private let web3Manager = Web3Manager()
    private let contractAddress = BlockchainConstants.orderManagerAddress

    // MARK: - On-Chain Order Creation

    func createOnChainOrder(_ order: Order) async throws -> BigUInt {
        guard let walletAddress = getConnectedAddress() else {
            throw OrderError.walletNotConnected
        }

        // Prepare product IDs array
        let productIds = order.items.map { $0.productId }

        // Encode createOrder function call
        let functionData = encodeCreateOrderCall(
            productIds: productIds,
            totalAmount: order.totalAmountInWei
        )

        // Build transaction
        let transaction = try await buildTransaction(
            to: contractAddress,
            value: 0,
            data: functionData
        )

        // Sign and send
        let txHash = try await transactionManager.signAndSendTransaction(transaction)

        // Wait for confirmation
        let receipt = try await transactionManager.waitForConfirmation(txHash: txHash)

        // Parse order ID from OrderCreated event
        let orderId = try parseOrderIdFromReceipt(receipt)

        return orderId
    }

    // MARK: - Order Status Updates

    func updateOrderStatus(orderId: BigUInt, newStatus: OrderStatus) async throws {
        // Only admin/backend can call this
        // For demo, skip authentication

        let functionData = encodeUpdateStatusCall(
            orderId: orderId,
            status: newStatus
        )

        let transaction = try await buildTransaction(
            to: contractAddress,
            value: 0,
            data: functionData
        )

        let txHash = try await transactionManager.signAndSendTransaction(transaction)
        _ = try await transactionManager.waitForConfirmation(txHash: txHash)
    }

    // MARK: - Order Cancellation

    func cancelOrder(orderId: BigUInt) async throws {
        let functionData = encodeCancelOrderCall(orderId: orderId)

        let transaction = try await buildTransaction(
            to: contractAddress,
            value: 0,
            data: functionData
        )

        let txHash = try await transactionManager.signAndSendTransaction(transaction)
        _ = try await transactionManager.waitForConfirmation(txHash: txHash)

        // This will trigger refund in PaymentEscrow automatically
    }

    // MARK: - Fetch Orders from Blockchain

    func fetchUserOrders(userAddress: String) async throws -> [BlockchainOrder] {
        let address = try EthereumAddress(hex: userAddress, eip55: true)

        // Call getOrdersByBuyer view function
        let function = OrderManagerFunctions.getOrdersByBuyer(buyer: address)

        let orderIds: [BigUInt] = try await web3Manager.readContract(
            contractAddress: try! EthereumAddress(hex: contractAddress, eip55: true),
            function: function
        )

        // Fetch each order's details
        var orders: [BlockchainOrder] = []

        for orderId in orderIds {
            let order = try await fetchOrderDetails(orderId: orderId)
            orders.append(order)
        }

        return orders
    }

    private func fetchOrderDetails(orderId: BigUInt) async throws -> BlockchainOrder {
        // Call orders(orderId) mapping getter
        let function = OrderManagerFunctions.getOrder(orderId: orderId)

        let orderData: OrderData = try await web3Manager.readContract(
            contractAddress: try! EthereumAddress(hex: contractAddress, eip55: true),
            function: function
        )

        return BlockchainOrder(
            id: orderId,
            buyer: orderData.buyer,
            productIds: orderData.productIds,
            totalAmount: orderData.totalAmount,
            status: OrderStatus(rawValue: orderData.status) ?? .placed,
            createdAt: Date(timeIntervalSince1970: TimeInterval(orderData.createdAt)),
            updatedAt: Date(timeIntervalSince1970: TimeInterval(orderData.updatedAt))
        )
    }

    // MARK: - Event Listening

    func listenForOrderEvents(fromBlock: BigUInt, completion: @escaping (OrderEvent) -> Void) {
        // Subscribe to OrderCreated, OrderPaid, OrderStatusUpdated, OrderCancelled events
        // Use web3.swift event filtering

        let eventFilter = EventFilter(
            type: .log,
            addresses: [try! EthereumAddress(hex: contractAddress, eip55: true)],
            topics: [
                [
                    OrderManagerEvents.orderCreated.signature,
                    OrderManagerEvents.orderStatusUpdated.signature,
                    OrderManagerEvents.orderCancelled.signature
                ]
            ]
        )

        // Poll for new events
        // In production, use WebSocket subscription
    }

    // MARK: - Helper Methods

    private func encodeCreateOrderCall(productIds: [String], totalAmount: BigUInt) -> Data {
        // ABI encode: createOrder(string[] memory productIds, uint256 totalAmount)
        let function = OrderManagerFunctions.createOrder(
            productIds: productIds,
            totalAmount: totalAmount
        )
        return function.data
    }

    private func parseOrderIdFromReceipt(_ receipt: TransactionReceipt) throws -> BigUInt {
        // Parse OrderCreated(uint256 indexed orderId, address indexed buyer, uint256 totalAmount)
        guard let log = receipt.logs.first(where: { $0.topics.first == OrderManagerEvents.orderCreated.signature }) else {
            throw OrderError.orderIdNotFound
        }

        let orderIdHex = log.topics[1] // First indexed parameter
        return BigUInt(orderIdHex.drop0x, radix: 16) ?? 0
    }
}

====================================================================
üìù IMPLEMENTATION: OrderSyncManager
====================================================================

import Foundation
import Combine
import CoreData

class OrderSyncManager {
    private let orderService: OrderService
    private let coreDataStack: CoreDataStack
    private var cancellables = Set<AnyCancellable>()

    private var isSyncing = false
    private let syncInterval: TimeInterval = 60 // Sync every 60 seconds

    init(orderService: OrderService, coreDataStack: CoreDataStack) {
        self.orderService = orderService
        self.coreDataStack = coreDataStack
        setupPeriodicSync()
    }

    // MARK: - Sync from Blockchain

    func syncOrders(for userAddress: String) async throws {
        guard !isSyncing else { return }

        isSyncing = true
        defer { isSyncing = false }

        // Fetch orders from blockchain
        let blockchainOrders = try await orderService.fetchUserOrders(userAddress: userAddress)

        // Save to CoreData
        let context = coreDataStack.newBackgroundContext()

        await context.perform {
            for blockchainOrder in blockchainOrders {
                self.upsertOrder(blockchainOrder, in: context)
            }

            do {
                try context.save()
            } catch {
                print("Failed to save synced orders: \(error)")
            }
        }
    }

    private func upsertOrder(_ blockchainOrder: BlockchainOrder, in context: NSManagedObjectContext) {
        // Check if order exists
        let fetchRequest: NSFetchRequest<OrderEntity> = OrderEntity.fetchRequest()
        fetchRequest.predicate = NSPredicate(format: "blockchainOrderId == %lld", blockchainOrder.id)

        if let existingOrder = try? context.fetch(fetchRequest).first {
            // Update existing
            existingOrder.orderStatus = blockchainOrder.status.rawValue
            existingOrder.updatedAt = blockchainOrder.updatedAt
            existingOrder.lastSyncedAt = Date()
            existingOrder.needsSync = false
        } else {
            // Create new
            let newOrder = OrderEntity(context: context)
            newOrder.id = UUID()
            newOrder.blockchainOrderId = Int64(blockchainOrder.id)
            newOrder.buyerAddress = blockchainOrder.buyer
            newOrder.totalAmount = NSDecimalNumber(value: blockchainOrder.totalAmount)
            newOrder.orderStatus = blockchainOrder.status.rawValue
            newOrder.createdAt = blockchainOrder.createdAt
            newOrder.updatedAt = blockchainOrder.updatedAt
            newOrder.lastSyncedAt = Date()
            newOrder.needsSync = false

            // Note: Product details would come from local cart or API
        }
    }

    // MARK: - Offline Queue

    func queueOfflineChange(orderId: UUID, action: OfflineAction) {
        let context = coreDataStack.newBackgroundContext()

        context.perform {
            let fetchRequest: NSFetchRequest<OrderEntity> = OrderEntity.fetchRequest()
            fetchRequest.predicate = NSPredicate(format: "id == %@", orderId as CVarArg)

            if let order = try? context.fetch(fetchRequest).first {
                order.needsSync = true
                // Store action details in a pending changes table
            }

            try? context.save()
        }
    }

    func processPendingChanges() async {
        let context = coreDataStack.newBackgroundContext()

        let pendingOrders = await context.perform {
            let fetchRequest: NSFetchRequest<OrderEntity> = OrderEntity.fetchRequest()
            fetchRequest.predicate = NSPredicate(format: "needsSync == YES")
            return try? context.fetch(fetchRequest)
        }

        guard let orders = pendingOrders else { return }

        for order in orders {
            // Process each pending change
            // Retry blockchain operations
            // Mark as synced on success
        }
    }

    // MARK: - Periodic Sync

    private func setupPeriodicSync() {
        Timer.publish(every: syncInterval, on: .main, in: .common)
            .autoconnect()
            .sink { [weak self] _ in
                Task {
                    guard let self = self,
                          let userAddress = WalletConnectionManager.shared.getAddress() else {
                        return
                    }
                    try? await self.syncOrders(for: userAddress)
                }
            }
            .store(in: &cancellables)
    }
}

====================================================================
üì± UI IMPLEMENTATION: OrderHistoryView
====================================================================

import SwiftUI
import CoreData

struct OrderHistoryView: View {
    @StateObject var viewModel: OrderHistoryViewModel
    @FetchRequest private var orders: FetchedResults<OrderEntity>

    init(viewModel: OrderHistoryViewModel) {
        _viewModel = StateObject(wrappedValue: viewModel)

        // CoreData fetch request
        _orders = FetchRequest(
            entity: OrderEntity.entity(),
            sortDescriptors: [NSSortDescriptor(keyPath: \OrderEntity.createdAt, ascending: false)],
            predicate: NSPredicate(format: "buyerAddress == %@", viewModel.userAddress)
        )
    }

    var body: some View {
        NavigationStack {
            List {
                ForEach(orders) { order in
                    NavigationLink(destination: OrderDetailView(order: order)) {
                        OrderRowView(order: order)
                    }
                }
            }
            .navigationTitle("My Orders")
            .refreshable {
                await viewModel.syncOrders()
            }
            .overlay {
                if orders.isEmpty {
                    EmptyStateView(
                        icon: "shippingbox",
                        title: "No Orders Yet",
                        message: "Your orders will appear here"
                    )
                }
            }
        }
    }
}

struct OrderRowView: View {
    let order: OrderEntity

    var body: some View {
        VStack(alignment: .leading, spacing: 8) {
            HStack {
                Text("Order #\(order.blockchainOrderId)")
                    .font(.headline)

                Spacer()

                OrderStatusBadge(status: OrderStatus(rawValue: order.orderStatus ?? "") ?? .placed)
            }

            Text("\(order.items?.count ?? 0) items ‚Ä¢ \(order.totalAmount ?? 0) COTI")
                .font(.subheadline)
                .foregroundColor(.secondary)

            Text(order.createdAt?.formatted() ?? "")
                .font(.caption)
                .foregroundColor(.secondary)
        }
        .padding(.vertical, 4)
    }
}

====================================================================
üì± UI: OrderDetailView
====================================================================

struct OrderDetailView: View {
    let order: OrderEntity
    @StateObject var viewModel: OrderDetailViewModel

    var body: some View {
        ScrollView {
            VStack(alignment: .leading, spacing: 24) {
                // Order status timeline
                orderStatusTimeline

                // Items section
                orderItemsSection

                // Payment information
                paymentSection

                // Blockchain info
                blockchainSection

                // Actions
                if canCancel {
                    cancelButton
                }

                if canRequestRefund {
                    refundButton
                }
            }
            .padding()
        }
        .navigationTitle("Order Details")
        .navigationBarTitleDisplayMode(.inline)
    }

    private var orderStatusTimeline: some View {
        VStack(alignment: .leading, spacing: 12) {
            Text("Order Status")
                .font(.headline)

            OrderTimelineView(
                currentStatus: OrderStatus(rawValue: order.orderStatus ?? "") ?? .placed
            )
        }
    }

    private var canCancel: Bool {
        let status = OrderStatus(rawValue: order.orderStatus ?? "") ?? .placed
        return status == .placed || status == .paid
    }

    private var canRequestRefund: Bool {
        let status = OrderStatus(rawValue: order.orderStatus ?? "") ?? .placed
        return status == .delivered
    }
}

====================================================================
üì§ DELIVERABLES
====================================================================

Provide complete code for:

1. Services:
   - OrderService.swift
   - OrderSyncManager.swift
   - RefundService.swift

2. CoreData:
   - CryptoStore.xcdatamodeld (data model)
   - CoreDataStack.swift
   - OrderEntity+Extensions.swift

3. Repository:
   - OrderRepository.swift

4. Use Cases:
   - GetOrdersUseCase.swift
   - CancelOrderUseCase.swift
   - RequestRefundUseCase.swift
   - TrackOrderUseCase.swift

5. ViewModels:
   - OrderHistoryViewModel.swift
   - OrderDetailViewModel.swift
   - RefundRequestViewModel.swift

6. Views:
   - OrderHistoryView.swift
   - OrderDetailView.swift
   - OrderRowView.swift
   - OrderTimelineView.swift
   - OrderStatusBadge.swift
   - RefundRequestView.swift

7. Models:
   - OrderStatus.swift (enum: Placed, Paid, Shipped, Delivered, Cancelled)
   - PaymentStatus.swift (enum)
   - BlockchainOrder.swift
   - OfflineAction.swift

8. Smart Contract Interfaces:
   - OrderManagerFunctions.swift (ABI functions)
   - OrderManagerEvents.swift (event signatures)

9. Documentation:
   - Order lifecycle diagram
   - Sync strategy explanation
   - Offline support guide
   - Testing scenarios

====================================================================
üîí DATA CONSISTENCY
====================================================================

Ensure:
‚úì Blockchain is source of truth
‚úì Local cache stays in sync
‚úì Conflict resolution favors blockchain
‚úì Optimistic UI updates with rollback
‚úì Network error handling
‚úì Retry mechanisms for failed syncs
‚úì Data validation before save

====================================================================
‚ö° PERFORMANCE OPTIMIZATION
====================================================================

Implement:
- Pagination for order history (fetch 20 at a time)
- Lazy loading of order details
- Background fetch for updates
- CoreData batch updates
- Index on blockchainOrderId and buyerAddress
- Cache blockchain queries
- Debounce sync requests

====================================================================
üéØ USER EXPERIENCE
====================================================================

Features:
- Pull-to-refresh order list
- Real-time status updates
- Push notifications for status changes
- Offline mode with sync indicators
- Search and filter orders
- Export order receipt as PDF
- Track shipping (if integrated)
- Contact support button

====================================================================
‚úÖ TESTING REQUIREMENTS
====================================================================

Test scenarios:
1. Create order while online
2. Create order while offline ‚Üí sync later
3. Cancel order
4. Request refund
5. Sync after app restart
6. Handle network errors
7. CoreData migration
8. Concurrent sync requests
9. Large order history (1000+ orders)
10. Blockchain reorg handling

Provide unit tests for all use cases.`}
    </div>

    {/* Visual Footer */}
    <div style={{
        background: '#020617',
        borderTop: '1px solid #1e293b',
        padding: '8px 20px',
        display: 'flex', justifyContent: 'flex-end',
        alignItems: 'center', gap: '10px'
    }}>
        <div style={{width:'8px', height:'8px', background:'#f59e0b', borderRadius:'50%', animation: 'pulse 2s infinite'}}></div>
        <span style={{fontSize: '0.7rem', color: '#94a3b8', fontFamily: 'sans-serif', fontWeight: 'bold'}}>
          SCROLL TO VIEW COMPLETE ORDER MANAGEMENT ‚Üï
        </span>
    </div>

  </div>
</div>

---

## üéì What You'll Build

After this phase, you'll have:

- ‚úÖ **Complete Order Lifecycle** - Creation to delivery
- ‚úÖ **Blockchain Synchronization** - Real-time state sync
- ‚úÖ **Offline Support** - Queue and sync later
- ‚úÖ **Order History** - Filterable, searchable list
- ‚úÖ **Refund System** - Request and process refunds
- ‚úÖ **Status Tracking** - Real-time updates
- ‚úÖ **CoreData Integration** - Fast local access
- ‚úÖ **Production Ready** - Tested and scalable

---

## üéâ Congratulations!

You've now built a **complete, production-ready crypto e-commerce iOS application**!

### What You've Mastered:

‚ú® **Clean Architecture** - Scalable, testable iOS architecture
‚ú® **Smart Contracts** - Solidity, escrow, and payment systems
‚ú® **SwiftUI** - Modern, beautiful UI/UX
‚ú® **WalletConnect** - Multi-wallet blockchain integration
‚ú® **Payment Processing** - Secure crypto transactions
‚ú® **Order Management** - Complete e-commerce backend

### Next Steps:

- Deploy to TestFlight for beta testing
- Add analytics and monitoring
- Implement customer support chat
- Add more payment methods
- Expand product catalog
- Launch on App Store!

**You're ready to build the future of commerce! üöÄ**
